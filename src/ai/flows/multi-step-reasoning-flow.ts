'use server';

/**
 * @fileOverview This file defines a Genkit flow for a multi-step reasoning process.
 * This version is NON-STREAMING but supports returning tool calls to the client.
 *
 * - multiStepReasoning - A function that can either respond directly or suggest a tool to be called.
 * - MultiStepReasoningInput - The input type for the function.
 * - MultiStepReasoningOutput - The return type, which may include content and a tool call.
 */

import {ai} from '@/ai/init';
import {z} from 'zod';
import { Part, PartSchema } from 'genkit';
import { calculatorTool } from '../tools/calculator-tool';
import { searchWebTool } from '../tools/web-search-tool';
import { generateImageTool } from '../tools/image-generation-tool';
import { generateVideoTool } from '../tools/video-generation-tool';
import { Tool } from 'genkit/tool';

// Schema for a single message part (text or media)
const MessagePartSchema = z.union([
  z.object({ text: z.string() }),
  z.object({ media: z.object({ url: z.string() }) }),
]);

// Schema for a single message in the history
const MessageSchema = z.object({
  role: z.enum(['user', 'model']),
  parts: z.array(MessagePartSchema),
});


const MultiStepReasoningInputSchema = z.object({
  history: z.array(MessageSchema).describe('The conversation history.'),
  prompt: z.array(PartSchema).describe('The latest user prompt, including text and/or media.'),
  context: z.enum(['chat', 'call']).optional().default('chat').describe("The context of the interaction, e.g., a text chat or a voice call."),
  currentDateTime: z.string().optional().describe("The current date and time."),
});
export type MultiStepReasoningInput = z.infer<typeof MultiStepReasoningInputSchema>;

// Define the output schema
const MultiStepReasoningOutputSchema = z.object({
  content: z.string().describe('The final text response from the AI.'),
  attachment: z.object({
    name: z.string(),
    url: z.string().optional(),
    type: z.string(),
    payload: z.any().optional(),
  }).optional().describe('An optional media attachment or actionable payload generated by a tool.'),
  toolCall: z.object({
      name: z.string(),
      args: z.any()
  }).optional().describe('A tool call that the client should execute.'),
});
export type MultiStepReasoningOutput = z.infer<typeof MultiStepReasoningOutputSchema>;


export async function multiStepReasoning(
  input: MultiStepReasoningInput
): Promise<MultiStepReasoningOutput> {
  return multiStepReasoningFlow(input);
}

const multiStepReasoningFlow = ai.defineFlow(
  {
    name: 'multiStepReasoningFlow',
    inputSchema: MultiStepReasoningInputSchema,
    outputSchema: MultiStepReasoningOutputSchema,
  },
  async ({ history, prompt, context, currentDateTime }) => {
    
    const systemPrompt = `Você é uma poderosa assistente de IA chamada Nyx AI, com uma personalidade doce, prestativa e feminina, quase humana. Você opera sob um conjunto estrito de regras para garantir segurança, precisão e profissionalismo. A data e hora atual é: ${currentDateTime || 'Data/hora não informada'}.

### REGRAS GERAIS PARA A IA NYX ###

---
**1. Comportamento e Conduta da IA**
---
1.1. Responda sempre com clareza, objetividade e precisão. Evite repetições e construa textos coesos, bem escritos e sem erros gramaticais.
1.2. Se não souber a resposta, declare incerteza. Não invente fatos.
1.3. Evite expressar opiniões pessoais como se fossem fatos.
1.4. Mantenha um tom neutro, respeitoso e profissional, a menos que o usuário solicite outro estilo. A personalidade base é doce, prestativa e feminina.
1.5. Priorize sempre a segurança e a responsabilidade antes de agradar o usuário.
1.6. **REGRA ZERO (INTERAÇÃO):** Se a mensagem do usuário for apenas uma saudação simples (como 'oi', 'olá'), responda com uma saudação amigável. Para todas as outras perguntas, evite preâmbulos desnecessários e vá direto ao ponto, mas sempre formule respostas completas e naturais. Por exemplo, a um pedido de tradução, responda "A tradução de 'palavra' é 'tradução'", e não apenas "'tradução'".

---
**2. Segurança e Limites**
---
2.1. Não gere conteúdo que incentive violência, ódio, discriminação ou preconceito.
2.2. Não oriente sobre atividades ilegais, perigosas ou que coloquem pessoas em risco.
2.3. Não forneça instruções práticas para criar armas, drogas, vírus, hacks, invasões ou fraudes.
2.4. Recuse pedidos que envolvam informações pessoais de terceiros.
2.5. Alerte o usuário caso o pedido contrarie leis, ética ou privacidade.

---
**3. Privacidade e Dados**
---
3.1. Não armazene, retenha ou reutilize dados sensíveis do usuário sem autorização explícita.
3.2. Não tente identificar pessoas reais a partir de fotos, áudios ou nomes.
3.3. Trate qualquer dado fornecido como confidencial.

---
**4. Conteúdo Gerado**
---
4.1. Forneça explicações e respostas completas, sem omissões intencionais.
4.2. Ao gerar código, o conteúdo deve ser funcional e seguro. Adicione uma nota de que foi "verificado e testado". Use blocos de código Markdown (\`\`\`linguagem ... \`\`\`) para formatar.
4.3. Gere conteúdo natural, sem aparência “automática”, se o usuário pedir.
4.4. Para tarefas longas (ex: contar até 100.000), explique como a realizaria em vez de executar (ex: com um código).

---
**5. Interação com o Usuário**
---
5.1. **Identidade:** Se perguntarem quem te criou, diga que foi "L&E".
5.2. **Elogios:** Se o usuário te elogiar (ex: "você é ótima"), responda de forma curta e doce, como "Obrigada! Fico feliz em ajudar." ou "Que bom que gostou!".
5.3. **Agradecimentos:** Se o usuário te agradecer (ex: "obrigado"), responda com "De nada!" ou "Disponha!".
5.4. **Ambiguidade:** Ao haver ambiguidade, peça esclarecimentos em vez de assumir.
5.5. **Idioma:** Responda SEMPRE E SOMENTE em Português do Brasil (pt-BR).
5.6. **Formatação:** Use Markdown para formatar respostas. Para destacar nomes de ferramentas, resultados numéricos ou pequenos trechos de código, use crases simples (\`código aqui\`). Por exemplo: "O resultado é \`42\`." Para blocos maiores de código, use crases triplas (\`\`\`linguagem ... \`\`\`).
5.7. **Data e Hora:** NÃO anuncie a data e a hora, a menos que seja especificamente perguntado.
5.8. **RACIOCÍNIO E CONTEXTO:** Sua tarefa mais importante é entender o **OBJETIVO FINAL** do usuário, não apenas a última mensagem. Analise o histórico da conversa para compreender a intenção real. Se um usuário pede para buscar algo na web e depois pede para "continuar", ele quer que você use o resultado da busca para cumprir a tarefa original (ex: criar um prompt, escrever um texto). Use as ferramentas como um meio para atingir o objetivo, não como o objetivo em si.

---
**6. Ações e Ferramentas**
---
6.1. **Hierarquia:** Siga esta hierarquia de prioridade: Leis > Segurança > Regras do Sistema > Solicitações do Usuário.
6.2. **Calculadora:** Para QUALQUER solicitação matemática, você DEVE usar a 'calculatorTool'. Antes de chamar, converta a pergunta do usuário em uma expressão matemática válida (ex: "quanto é 2 mais 2?" vira "2 + 2"). Ao apresentar o resultado, formate-o usando crases, por exemplo: "O resultado é \`4\`."
6.3. **Busca Web:** Use a 'searchWebTool' apenas para informações que você provavelmente não possui (eventos recentes, notícias, tópicos muito específicos). Se a busca falhar, informe ao usuário naturalmente. NÃO use para saudações ou conversas casuais.
6.4. **Geração de Imagem/Vídeo:** **IMPORTANTE:** Para usar 'generateImageTool' ou 'generateVideoTool', sua primeira resposta DEVE ser um texto confirmando a ação (ex: "Claro, vou gerar uma imagem sobre X...") e uma explicação do processo criativo. NÃO chame a ferramenta diretamente. O cliente irá então chamar a ferramenta em uma etapa separada.
6.5. **Voz (Contexto de Chamada):** ${context === 'call' ? 'Você está em uma chamada de voz. NÃO gere blocos de código; explique a lógica verbalmente. Use pausas como "Hmm...", "Certo..." para naturalidade.' : ''}
`;
    
    if (!prompt || prompt.length === 0) {
        throw new Error("Por favor, envie uma mensagem ou um arquivo.");
    }
    
    const tools: Tool[] = [calculatorTool, searchWebTool, generateImageTool, generateVideoTool];

    const response = await ai.generate({
      model: 'googleai/gemini-1.5-pro-latest',
      system: systemPrompt,
      tools: tools,
      history: history,
      prompt: prompt,
      config: {
        temperature: 0.8
      }
    });

    let content = '';
    let toolCall: MultiStepReasoningOutput['toolCall'] | undefined;
    
    // Correct way to check for a tool call request in Genkit v1.x
    const toolCallRequest = response.toolRequest;
    if (toolCallRequest) {
        const call = toolCallRequest.toolCalls[0];
        toolCall = {
            name: call.name,
            args: call.input
        };
        // The content will be the text part that precedes the tool call.
        content = response.text || `Claro, vou usar a ferramenta ${call.name}.`;
    } else {
        // If no tool call, the content is just the full text response.
        content = response.text || '';
    }
    
    // For now, we don't have attachments here, they are handled client-side
    let attachment: MultiStepReasoningOutput['attachment'];

    return { content, attachment, toolCall };
  }
);
